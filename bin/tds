#!/usr/bin/env python

import argparse
import logging
import os.path
import sys
import yaml

import tds.cmdline
import tds.logging_wrapper as log_wrap
import tds.version


conf_dir = '/etc/tagops'
conf_log_params = [ 'syslog_facility', 'syslog_priority', ]


def create_subparsers(parser):
    """Generate the subparsers to use for the command line"""

    data = tds.cmdline.parser_info()

    cmd_parsers = parser.add_subparsers(dest='command_name',
                                        help='command help')

    for cmd, cmd_data in data.iteritems():
        cmd_parser = cmd_parsers.add_parser(cmd)

        subparsers = cmd_parser.add_subparsers(dest='subcommand_name',
                                               help='subcommand help')

        for subcmd, subcmd_data in cmd_data.iteritems():
            subcmd_parser = subparsers.add_parser(subcmd,
                                                  help=subcmd_data['help'])

            for args, kwargs in subcmd_data['subargs'].iteritems():
                subcmd_parser.add_argument(*args, **kwargs)


def parse_command_line():
    """Parse the command line and return the parser to the main program"""

    parser = argparse.ArgumentParser(description='TagOps Deployment System')

    parser.add_argument('-V', '--version', action='version',
                        version='TDS %s' % tds.version.__version__)
    parser.add_argument('-v', '--verbose', action='count',
                        help='Show more information (more used shows greater '
                             'information)')
    parser.add_argument('--dbuser', help='Specify user to use to connect '
                                         'to TagOpsDB',
                                    default=None)

    create_subparsers(parser)

    return parser.parse_args()


def verify_logging_conf_file_info():
    """Customized version of verify_conf_file_section() in tds.utils
       to avoid circular dependencies with logging configuration
    """

    try:
        with open(os.path.join(conf_dir, 'deploy.yml')) as fh:
            try:
                data = yaml.load(fh.read())
            except yaml.parser.ParserError, e:
                print 'YAML parse error: %s' % e
                sys.exit(1)
    except IOError, e:
        print 'Unable to access the configuration file "deploy.yml": %s' % e
        sys.exit(1)

    for param in conf_log_params:
        try:
            data['logging'][param]
        except KeyError:
            print 'Missing entry "%s" in "logging" section of ' \
                  'configuration file "deploy.yml"' % param

    return [ data['logging'][x] for x in conf_log_params ]


def configure_logging(verbosity):
    """Configure logging for the application; this will set up
       the initial syslog and console loggers and handlers for
       the application
    """

    sqla_level = logging.WARNING
    log_prefix = True

    if verbosity is None:
        level = None
        log_prefix = False   # Don't prefix for normal use
    elif verbosity == 1:
        level = 10
    elif verbosity == 2:
        level = 5
    else:
        level = 1
        sqla_level = 1   # Ensure SQLAlchemy gives full log info

    syslog_facility, syslog_priority = verify_logging_conf_file_info()

    logging.setLoggerClass(log_wrap.Logger)

    logger = logging.getLogger()
    log_wrap.add_syslog(logger, 'syslog',
                        facility=log_wrap.facilities[syslog_facility],
                        priority=log_wrap.priorities[syslog_priority])
    log_wrap.add_stream(logger, 'stderr', stream=sys.stderr,  
                        prefix=log_prefix)

    tds_logger = logging.getLogger('tds')
    log_wrap.add_stream(tds_logger, 'stdout', stream=sys.stdout,
                        level=level, nostderr=True, prefix=log_prefix)

    sqla_logger = logging.getLogger('sqlalchemy.engine')
    sqla_logger.setLevel(1)
    log_wrap.add_stream(sqla_logger, 'stdout', stream=sys.stdout,
                        level=sqla_level, nostderr=True,
                        prefix=log_prefix)

    tds_logger.log(100, 'Trying right after logging configuration')
    print 'tds_logger handlers are: %r' % tds_logger.handlers
    print 'tds_logger stream is: %r' % tds_logger.handlers[0].stream
    print 'tds_logger handler level is: %r' % tds_logger.handlers[0].level
    print 'tds_logger handler actual level is: %r' % tds_logger.getEffectiveLevel()
    return tds_logger


if __name__ == '__main__':
    args = parse_command_line()
    args.log = configure_logging(args.verbose)
    args.log.info('Testing initial log configuration')

    # Must be done *after* logging is configured
    import tds.main

    prog = tds.main.TDS(args)
    prog.check_exclusive_options()
    prog.update_program_parameters()
    prog.initialize_db()
    prog.execute_command()
