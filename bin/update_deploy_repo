#!/usr/bin/env python2.6

import collections
import os
import os.path
import shlex
import shutil
import smtplib
import socket
import subprocess
import sys
import time

from email.mime.text import MIMEText

import daemonize
import yaml
import yaml.parser

from kazoo.client import KazooClient   # , KazooState
from sqlalchemy.orm import scoped_session, sessionmaker

import tagopsdb.deploy.package as package

from tagopsdb.database import init_session
from tagopsdb.exceptions import RepoException


class ExtCommandError(Exception):
    pass


class Zookeeper(object):
    """ """

    def __init__(self, hostname, servers):
        """Set up election for Zookeeper"""

        self.zk = KazooClient('hosts=%s' % ','.join(servers))
        # self.zk.add_listener(self.my_listener)
        self.election = self.zk.Election('/deployrepo', hostname)


    def my_listener(self, state):
        """Manage connection to Zookeeper"""

        pass   # Do we need to do anything here?


    def run(self, elect_method, *args):
        """Run passed method with given arguments when election is won"""

        self.election.run(elect_method, *args)


def run(cmd, expect_return_code=0, env=None, shell=False):
    """Wrapper to run external command"""

    if isinstance(cmd, basestring):
        args = shlex.split(cmd.replace('\\', '\\\\'))
    else:
        args = cmd

    try:
        proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE, env=env, shell=shell)
    except OSError as e:
        exc = subprocess.CalledProcessError(1, args)
        exc.stderr = 'Error using Popen: %s' % e
        exc.stdout = None
        raise exc

    stdout, stderr = proc.communicate()

    if not (expect_return_code is None or
            expect_return_code == proc.returncode):
        exc = subprocess.CalledProcessError(proc.returncode, args)
        exc.stderr = stderr
        exc.stdout = stdout
        raise exc

    Process = collections.namedtuple('Process',
                                     ['stdout', 'stderr', 'returncode'])

    return Process(stdout=stdout, stderr=stderr, returncode=proc.returncode)


def prepare_rpms(incoming_dir, process_dir, files):
    """Move RPMs in incoming directory to the processing directory"""

    daemonize.logging.info('Moving files in incoming directory to '
                           'processing directory...')

    for rpm in files:
        src_rpm = os.path.join(incoming_dir, rpm)
        dst_rpm = os.path.join(process_dir, rpm)

        try:
            # A rename should very rarely fail, so leaving uncaught
            os.rename(src_rpm, dst_rpm)
        except OSError as e:
            raise RepoException('Unable to move file "%s" to "%s": %s'
                                % (src_rpm, process_dir, e))


def email_for_invalid_rpm(rpm_file):
    """Send an email to engineering if a bad RPM is found"""

    sender = 'siteops'
    sender_email = '%s@tagged.com' % sender
    receiver_emails = [ 'eng+tds@tagged.com' ]

    msg = MIMEText('The RPM file "%s" is invalid, the builder of it should '
                   'check the build process' % rpm_file)

    msg['Subject'] = '[TDS] Invalid RPM file "%s"' % rpm_file
    msg['From'] = sender_email
    msg['To'] = ', '.join(receiver_emails)

    s = smtplib.SMTP('localhost')
    s.sendmail(sender, receiver_emails, msg.as_string())
    s.quit()


def update_repo(repo_dir, process_dir, session):
    """Copy RPMs in processing directory to the repository and run
       update the repo
    """

    valid_rpms = []
    rpms_to_process = [ os.path.join(process_dir, f)
                        for f in os.listdir(process_dir) ]

    for rpm_to_process in rpms_to_process:
        daemonize.logging.info('Verifying file %s and if valid moving to '
                               'repository' % rpm_to_process)

        # TODO: ensure package is valid (security purposes)

        cmd = [ 'rpm', '-qp', '--queryformat',
                '%{arch},%{name},%{version},%{release}', rpm_to_process ]

        try:
            rpm_info = run(cmd)
        except subprocess.CalledProcessError as e:
            email_for_invalid_rpm(rpm_to_process)
            os.unlink(rpm_to_process)
            daemonize.logging.error('rpm command failed: %s' % e)
            continue

        arch_type, name, version, release = rpm_info.stdout.split(',')
        dest_dir = os.path.join(repo_dir, arch_type)

        pkg = package.find_package(name, version, release)

        if pkg is None:
            raise RepoException('Missing entry for package "%s", version %s, '
                'revision %s in database' % (name, version, release))

        try:
            shutil.copy(rpm_to_process, dest_dir)
        except IOError as e:
            time.sleep(2)   # Short delay before re-attempting

            try:
                shutil.copy(rpm_to_process, dest_dir)
            except IOError as e:
                pkg.status = 'failed'
                session.commit()

                os.unlink(rpm_to_process)
                daemonize.logging.error('Unable to copy file "%s" to "%s": %s'
                                        % (rpm_to_process, dest_dir, e))
                continue

        pkg.status = 'completed'
        session.commit()

        valid_rpms.append((rpm_to_process, name, version, release))

    daemonize.logging.info('Updating repo...')
    old_umask = os.umask(0002)

    try:
        run([ 'make', '-C', repo_dir ])
    except subprocess.CalledProcessError as e:
        daemonize.logging.error('yum database update failed, retrying: %s', e)
        time.sleep(5)   # Short delay before re-attempting

        try:
            run([ 'make', '-C', repo_dir ])
        except subprocess.CalledProcessError as e:
            # Yes, making the assumption none of the package finds
            # will fail...
            for rpm_to_process in valid_rpms:
                pkg = package.find_package(*rpm_to_process[1:])
                pkg.status = 'failed'
                session.commit()

            daemonize.logging.error('yum database update failed, aborting: '
                                    '%s', e)

    os.umask(old_umask)
    daemonize.logging.info('Removing processed files...')
    # Yes, making the assumption none of the package finds will fail...
    # yet again...
    for rpm_to_process in valid_rpms:
        pkg = package.find_package(*rpm_to_process[1:])
        pkg.status = 'completed'
        session.commit()

        os.unlink(rpm_to_process[0])


def process_incoming_directory(repo_dir, incoming_dir, process_dir, session):
    """"""

    daemonize.logging.info('Checking for incoming files...')

    while True:
        files = os.listdir(incoming_dir)

        if files:
            daemonize.logging.info('Files found, processing them...')
            prepare_rpms(incoming_dir, process_dir, files)
            update_repo(repo_dir, process_dir, session)
            daemonize.logging.info('Done processing, checking for incoming '
                                   'files...')

        time.sleep(1.0)


def main():
    """Read configuration file and get relevant information, then try to
       process files in the incoming directory if single system or zookeeper
       leader in multi-system configuration
    """

    data = None

    daemonize.logging.info('Reading database access (dbaccess.admin.yml) '
                           'file')

    with open('/etc/tagops/dbaccess.admin.yml') as db_file:
        try:
            data = yaml.load(db_file.read())
        except yaml.parser.ParserError as e:
            raise RuntimeError('YAML parse error: %s' % e)

    if 'db' not in data:
        raise RuntimeError('YAML configuration missing "db" section')

    try:
        db_user = data['db']['user']
        db_password = data['db']['password']
    except KeyError as e:
        raise RuntimeError('YAML configuration missing necessary parameter '
                           'in "db" section: %s' % e)

    daemonize.logging.info('Initializing database session')
    init_session(db_user, db_password)
    session = scoped_session(sessionmaker())

    daemonize.logging.info('Reading configuration (deploy.yml) file')

    with open('/etc/tagops/deploy.yml') as conf_file:
        try:
            data = yaml.load(conf_file.read())
        except yaml.parser.ParserError, e:
            raise RepoException('YAML parse error: %s' % e)

    if 'yum' not in data:
        raise RuntimeError('YAML configuration missing "yum" section')

    try:
        repo_dir = data['yum']['repo_location']
        incoming_dir = data['yum']['incoming']
        process_dir = data['yum']['processing']
    except KeyError as e:
        raise RuntimeError('YAML configuration missing necessary parameter '
                           'in "yum" section: %s' % e)

    if 'zookeeper' in data:
        hostname = socket.gethostname()

        zk = Zookeeper(hostname, data['zookeeper'])
        zk.run(process_incoming_directory, repo_dir, incoming_dir,
               process_dir, session)
    else:
        process_incoming_directory(repo_dir, incoming_dir, process_dir,
                                   session)


def safe_main():
    """A wrapper for the main process to ensure any unhandled
       exceptions are logged before the daemon exits
    """

    try:
        main()
    except:
        value = sys.exc_info()[1]
        e = "Unhandled exception: %s.  Daemon exiting." % value
        daemonize.logging.error(e)
        sys.exit(1)


pid = '/var/run/update_deploy_repo.pid'
logfile = '/var/log/update_deploy_repo.log'

daemonize.start(safe_main, pid, logfile)
