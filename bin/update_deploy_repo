#!/usr/bin/env python2.6

import os
import os.path
import shlex
import shutil
import socket
import subprocess
import sys
import time

import daemonize
import yaml

from tagopsdb.exceptions import RepoException


class ExtCommandError(Exception):
    pass


class Zookeeper(object):
    """ """

    from kazoo.client import KazooClient, KazooState


    def __init__(self, hostname, servers):
        """ """

        self.zk = KazooClient('hosts=%s' % ','.join(servers))
        # self.zk.add_listener(self.my_listener)
        self.election = self.zk.Election('/deployrepo', hostname)


    def my_listener(self, state):
        """"""

        pass   # Do we need to do anything here?


    def run(self, elect_method):
        """"""

        self.election.run(elect_method)


def run(cmd, expect_return_code=0, env=None, shell=False):
    """Wrapper to run external command"""

    if isinstance(cmd, basestring):
        args = shlex.split(cmd.replace('\\', '\\\\'))
    else:
        args = cmd

    try:
        proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE, env=env, shell=shell)
    except OSError:
        raise ExtCommandError('Error using Popen: args were %r' % args)

    stdout, stderr = proc.communicate()

    if not (expect_return_code is None or
            expect_return_code == proc.returncode):
        exc = subprocess.CalledProcessError(proc.returncode, args)
        exc.stderr = stderr
        exc.stdout = stdout
        raise exc

    return dict(stdout=stdout, stderr=stderr, return_code=proc.returncode)


def run_command(cmd):
    """Wrapper to run external command"""

    cmdline = ' '.join(cmd)
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)

    stdout, stderr = proc.communicate()

    if proc.returncode:
        raise ExtCommandError('Command "%s" failed:\n%s' % (cmdline, stderr))

    return stdout


def prepare_rpms(incoming_dir, process_dir, files):
    """Move RPMs in incoming directory to the processing directory"""

    daemonize.logging.info('Moving files in incoming directory to '
                           'processing directory...')

    for rpm in files:
        try:
            src_rpm = os.path.join(incoming_dir, rpm)
            shutil.move(src_rpm, process_dir)
        except IOError, e:
            raise RepoException('Unable to move file "%s" to "%s": %s'
                                % (src_rpm, process_dir, e))


def update_repo(repo_dir, process_dir):
    """Copy RPMs in processing directory to the repository and run
       update the repo
    """

    invalid_rpms = []
    rpms_to_process = [ os.path.join(process_dir, f)
                        for f in os.listdir(process_dir) ]

    for rpm_to_process in rpms_to_process:
        daemonize.logging.info('Verifying file %s and if valid moving to '
                               'repository' % rpm_to_process)

        # TODO: ensure package is valid (security purposes)

        cmd = [ 'rpm', '-qp', '--queryformat', '%{arch}', rpm_to_process ]

        try:
            arch_type = run_command(cmd)
        except ExtCommandError, e:
            invalid_rpms.append(rpm_to_process)
            daemonize.logging.error(e)
            continue

        try:
            dest_dir = os.path.join(repo_dir, arch_type)
            shutil.copy(rpm_to_process, dest_dir)
        except IOError, e:
            raise RepoException('Unable to copy file "%s" to "%s": %s'
                                % (rpm_to_process, dest_dir, e))

    daemonize.logging.info('Updating repo...')

    try:
        old_umask = os.umask(0002)
        run_command([ 'make', '-C', repo_dir ])
        os.umask(old_umask)
    except ExtCommandError, e:
        raise RepoException(e)

    daemonize.logging.info('Removing processed files...')

    for rpm_to_process in rpms_to_process:
        if rpm_to_process not in invalid_rpms:
            os.unlink(rpm_to_process)


def process_incoming_directory(repo_dir, incoming_dir, process_dir):
    """"""

    daemonize.logging.info('Checking for incoming files...')

    while True:
        files = os.listdir(incoming_dir)

        if files:
            daemonize.logging.info('Files found, processing them...')
            prepare_rpms(incoming_dir, process_dir, files)
            update_repo(repo_dir, process_dir)
            daemonize.logging.info('Done processing, checking for incoming '
                                   'files...')

        time.sleep(1.0)


def main():
    """Read configuration file and get relavent information, then try to
       process files in the incoming directory if single system or zookeeper
       leader in multi-system configuration
    """

    daemonize.logging.info('Reading configuration (deploy.yml) file')

    with open('/etc/tagops/deploy.yml') as conf_file:
        try:
            data = yaml.load(conf_file.read())
        except yaml.parser.ParserError, e:
            raise RepoException('YAML parse error: %s' % e)

    repo_dir = data['yum']['repo_location']
    incoming_dir = data['yum']['incoming']
    process_dir = data['yum']['processing']

    if 'zookeeper' in data:
        hostname = socket.gethostname()

        zk = Zookeeper(hostname, data['zookeeper'])
        zk.run(process_incoming_directory, repo_dir, incoming_dir,
               process_dir)
    else:
        process_incoming_directory(repo_dir, incoming_dir, process_dir)


def safe_main():
    """A wrapper for the main process to ensure any unhandled
       exceptions are logged before the daemon exits
    """

    try:
        main()
    except:
        exctype, value = sys.exc_info()[:2]
        e = "Unhandled exception: %s.  Daemon exiting." % value
        daemonize.logging.error(e)
        sys.exit(1)


pid = '/var/run/update_deploy_repo.pid'
logfile = '/var/log/update_deploy_repo.log'

daemonize.start(safe_main, pid, logfile)
