#!/usr/bin/env python2.6

import collections
import os
import os.path
import shlex
import shutil
import socket
import subprocess
import sys
import time

import daemonize
import yaml
import yaml.parser

from kazoo.client import KazooClient   # , KazooState

from tagopsdb.exceptions import RepoException


class ExtCommandError(Exception):
    pass


class Zookeeper(object):
    """ """

    def __init__(self, hostname, servers):
        """Set up election for Zookeeper"""

        self.zk = KazooClient('hosts=%s' % ','.join(servers))
        # self.zk.add_listener(self.my_listener)
        self.election = self.zk.Election('/deployrepo', hostname)


    def my_listener(self, state):
        """Manage connection to Zookeeper"""

        pass   # Do we need to do anything here?


    def run(self, elect_method, *args):
        """Run passed method with given arguments when election is won"""

        self.election.run(elect_method, *args)


def run(cmd, expect_return_code=0, env=None, shell=False):
    """Wrapper to run external command"""

    if isinstance(cmd, basestring):
        args = shlex.split(cmd.replace('\\', '\\\\'))
    else:
        args = cmd

    try:
        proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE, env=env, shell=shell)
    except OSError as e:
        exc = subprocess.CalledProcessError(1, args)
        exc.stderr = 'Error using Popen: %s' % e
        exc.stdout = None
        raise exc

    stdout, stderr = proc.communicate()

    if not (expect_return_code is None or
            expect_return_code == proc.returncode):
        exc = subprocess.CalledProcessError(proc.returncode, args)
        exc.stderr = stderr
        exc.stdout = stdout
        raise exc

    Process = collections.namedtuple('Process',
                                     ['stdout', 'stderr', 'returncode'])

    return Process(stdout=stdout, stderr=stderr, returncode=proc.returncode)


def prepare_rpms(incoming_dir, process_dir, files):
    """Move RPMs in incoming directory to the processing directory"""

    daemonize.logging.info('Moving files in incoming directory to '
                           'processing directory...')

    for rpm in files:
        src_rpm = os.path.join(incoming_dir, rpm)
        dst_rpm = os.path.join(process_dir, rpm)

        try:
            # This should only fail in exceptional circumstances
            os.rename(src_rpm, dst_rpm)
        except OSError as e:
            raise RepoException('Unable to move file "%s" to "%s": %s'
                                % (src_rpm, process_dir, e))


def update_repo(repo_dir, process_dir):
    """Copy RPMs in processing directory to the repository and run
       update the repo
    """

    valid_rpms = []
    rpms_to_process = [ os.path.join(process_dir, f)
                        for f in os.listdir(process_dir) ]

    for rpm_to_process in rpms_to_process:
        daemonize.logging.info('Verifying file %s and if valid moving to '
                               'repository' % rpm_to_process)

        # TODO: ensure package is valid (security purposes)

        cmd = [ 'rpm', '-qp', '--queryformat', '%{arch}', rpm_to_process ]

        try:
            arch_type = run(cmd)
        except subprocess.CalledProcessError as e:
            # TODO: Update database to mark file as 'failed'
            os.unlink(rpm_to_process)
            daemonize.logging.error('rpm command failed: %s' % e)
            continue

        dest_dir = os.path.join(repo_dir, arch_type.stdout)

        try:
            shutil.copy(rpm_to_process, dest_dir)
        except IOError as e:
            time.sleep(2)   # Short delay before re-attempting

            try:
                shutil.copy(rpm_to_process, dest_dir)
            except IOError as e:
                # TODO: Update database to mark file as 'failed'
                os.unlink(rpm_to_process)
                daemonize.logging.error('Unable to copy file "%s" to "%s": %s'
                                        % (rpm_to_process, dest_dir, e))
                continue

        # RPM is good, add to success list
        valid_rpms.append(rpm_to_process)

    daemonize.logging.info('Updating repo...')
    old_umask = os.umask(0002)

    try:
        run([ 'make', '-C', repo_dir ])
    except subprocess.CalledProcessError as e:
        daemonize.logging.error('yum database update failed, retrying: %s', e)
        time.sleep(5)   # Short delay before re-attempting

        try:
            run([ 'make', '-C', repo_dir ])
        except subprocess.CalledProcessError as e:
            # TODO: Update database to mark all valid files as 'failed'
            daemonize.logging.error('yum database update failed, aborting: '
                                    '%s', e)

    os.umask(old_umask)
    daemonize.logging.info('Removing processed files...')
    # TODO: Update database to mark all valid files as 'ok'

    for rpm_to_process in valid_rpms:
        os.unlink(rpm_to_process)


def process_incoming_directory(repo_dir, incoming_dir, process_dir):
    """"""

    daemonize.logging.info('Checking for incoming files...')

    while True:
        files = os.listdir(incoming_dir)

        if files:
            daemonize.logging.info('Files found, processing them...')
            prepare_rpms(incoming_dir, process_dir, files)
            update_repo(repo_dir, process_dir)
            daemonize.logging.info('Done processing, checking for incoming '
                                   'files...')

        time.sleep(1.0)


def main():
    """Read configuration file and get relevant information, then try to
       process files in the incoming directory if single system or zookeeper
       leader in multi-system configuration
    """

    data = None
    daemonize.logging.info('Reading configuration (deploy.yml) file')

    with open('/etc/tagops/deploy.yml') as conf_file:
        try:
            data = yaml.load(conf_file.read())
        except yaml.parser.ParserError, e:
            raise RepoException('YAML parse error: %s' % e)

    if 'yum' not in data:
        raise RuntimeError('YAML configuration missing "yum" section')

    try:
        repo_dir = data['yum']['repo_location']
        incoming_dir = data['yum']['incoming']
        process_dir = data['yum']['processing']
    except KeyError as e:
        raise RuntimeError('YAML configuration missing necessary parameter '
                           'in "yum" section: %s' % e)

    if 'zookeeper' in data:
        hostname = socket.gethostname()

        zk = Zookeeper(hostname, data['zookeeper'])
        zk.run(process_incoming_directory, repo_dir, incoming_dir,
               process_dir)
    else:
        process_incoming_directory(repo_dir, incoming_dir, process_dir)


def safe_main():
    """A wrapper for the main process to ensure any unhandled
       exceptions are logged before the daemon exits
    """

    try:
        main()
    except:
        value = sys.exc_info()[1]
        e = "Unhandled exception: %s.  Daemon exiting." % value
        daemonize.logging.error(e)
        sys.exit(1)


pid = '/var/run/update_deploy_repo.pid'
logfile = '/var/log/update_deploy_repo.log'

daemonize.start(safe_main, pid, logfile)
